
### 工业级的散列表应该具有那些特性？
- 快速的查询、插入、删除操作
- 内存占用合理，不能浪费过多内存
- 性能稳定，极端情况下，散列表的性能也不会退化到无法接受的情况

### 如何实现散列表？
- 设计合适的散列函数
- 定义装载因子阈值，并且设计动态扩容策略
- 合适的散列冲突解决方法

### 工业级散列表举例分析
Java中的HashMap

1. 初始大小

默认16，可以修改默认初始大小，减少动态扩容的次数，大大提高性能

2. 装载因子和动态扩容

默认0.75，当元素超过0.75容量使，自动扩容，每次扩容为原来的两倍

3. 散列冲突解决办法

底层采用链表，长度太长（默认8），转换为红黑树，少于6，转为链表

4. 散列函数

追求简单高效、分布均匀


### 如何避免低效的扩容？
- 特殊情况下，当装载因子已经达到阈值，需要先扩容，再插入数据，此时，插入数据就会变的很慢，甚至无法接受
- 一次性扩容机制不合适
- 当装载因子达到阈值，我们只申请空间，并不把老数据搬到新散列表中
- 当有新数据插入时，我们将新数据插入新散列表中，并且从老的散列表拿出一个数据搬到新散列表
- 经过多次插入操作，老的散列表就全部搬到新散列表中，均摊的方法，任何情况下，插入数据的时间复杂度都是O(1)
- 查询操作，为了兼容新、老散列表，先从新散列表查找，未找到再去老的散列表
